//4.1   表达式5 + 10 * 20 / 2的求值结果是多少？
//解：
//      5 + ((10 * 20) / 2) = 105

//4.2   根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。
//      (a) *vec.begin() (b) *vec.begin() + 1
//解：
//      (a) *(vec.begin())
//      (b) (*(vec.begin())) + 1

//4.3   C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。
//      这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。
//解：
//      没有强制规定顺序给效率提升提供了可能，但是对于水平较低的程序员更容易造成问题。

//4.4   在下面的表达式中添加括号，说明其求值过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。
//      12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
//解：
//      ((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2) = 16 + 75 + 0 = 91
//      #include<iostream>
//      int main()
//      {
//          std::cout << 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2 << std::endl;
//          return 0;
//      }

//4.5   写出下列表达式的求值结果。
//解：  
//      -30 * 3 + 21 / 5 = -90 + 4 = -86
//      -30 + 3 * 21 / 5 = -30 + 63 / 5 = -30 + 12 = -18
//      30 / 3 * 21 % 5 = 10 * 21 % 5 = 210 % 5 = 0
//      -30 / 3 * 21 % 4 = -10 * 21 % 4 = -210 % 4 = -2

//4.6   写出一条表达式用于确定一个整数是奇数还是偶数。
//解：
//      if ( i % 2 == 0) { /*...*/ }

//4.7   溢出是何含义？写出三条将导致溢出的表达式。
//解：
//      short short_value = 32767; ++short_value;   //from book
//      unsigned unsigned_value = 0; --unsigned_value;   //unsigned >= 0
//      unsigned char unsigned_char_value = 255; ++unsigned_char_value;   // 0-255

//4.8   说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。
//解：
//      逻辑与、或运算符从左到右计算，按照短路求值策略；相等性运算时未规定顺序。

//4.9   解释在下面的if语句中条件部分的判断过程。
//      const char *cp = "Hello World";
//      if (cp && *cp)
//解：
//      && 是逻辑与运算符，按照短路求值策略，先判断 cp 是否为一个空指针，为真；接下来判断 *cp 的值是否为空，为真。
//      因此按照逻辑与的运算规则，左右均为真则结果为真。


//4.10   为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。
//解：
//      while ( cin >> i && i != 42)

//4.11   书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。
//解：
//      a > b && b > c && c > d

//4.12   假设i、j和k是三个整数，说明表达式i != j < k的含义。
//解：
//      < 运算符的优先级比 ！= 要更高，因此表达式可以改写为 i != ( j < k )，即首先判断 j 与 k 的大小关系。
//      若 j < k，则判断 i != 1；若 j >= k，则判断 i != 0。最终得到一个 bool 类型的结果。

//4.13   在下述语句中，当赋值完成后 i 和 d 的值分别是多少？
//解：
//      int i;   double d;
//      d = i = 3.5;    // i = 3, d = 3.0
//      i = d = 3.5;    // d = 3.5, i = 3

//4.14   执行下述 if 语句后将发生什么情况？
//解：
//      if (42 = i)   // error，赋值运算符左侧是左值
//      if (i = 42)   // true.

//4.15   下面的赋值是非法的，为什么？应该如何修改？
//      double dval; int ival; int *pi;
//      dval = ival = pi = 0;
//解：
//      pi = 0，这一步是给指针 int* 赋值，不能继续赋值给 int 型变量 ival。
//      可改为 dval = ival = 0; pi = 0;

//4.16   尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？
//      if (p = getPtr() != 0)
//      if (i = 1024)
//解：
//      if ((p = getPtr()) != 0)    //先给 p 赋值，再判断
//      if (i == 1024)    //i = 1024是进行赋值，再判断为真；此处应该是判断 i 是否等于 1024

//4.17   说明前置递增运算符和后置递增运算符的区别。
//解：
//      前置递增运算符先 +1，后将改变后的对象本身作为左值返回；
//      后置递增运算符将对象原始值的副本作为右值返回，之后执行 +1。

//4.18   如果132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？
//解：
//      会跳过第一个元素，直接从第二个开始取值。并且在最后取v.end()，得到一个未定义的值。

//4.19   假设ptr的类型是指向int的指针、vec的类型是vector、ival的类型是int.
//       说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？
//       (a) ptr != 0 && *ptr++  
//       (b) ival++ && ival
//       (c) vec[ival++] <= vec[ival] 
//解：
//       (a)首先，判断ptr是否不是一个空指针，并且ptr当前指向的元素的值也为真，然后将ptr指向下一个位置。
//       (b)先判断ival的值是否为真，接下来ival + 1后，判断ival + 1的值是否也为真
//       (c)无法判断 <= 运算符两边的运算顺序，如果是类比(b)中的含义，应该改为vec[ival] <= vec[ival+1]

//4.20   假设iter的类型是vector::iterator, 说明下面的表达式是否合法。
//       如果合法，表达式的含义是什么？如果不合法，错在何处？
//      (a) *iter++;
//      (b) (*iter)++;
//      (c) *iter.empty();
//      (d) iter->empty();
//      (e) ++*iter;
//      (f) iter++->empty();
//解：
//      (a) *iter++;    合法。先返回*iter，再iter++
//      (b) (*iter)++;    非法。*iter得到string对象，无法进行++操作
//      (c) *iter.empty();    非法。iter作为迭代器，应当使用iter->empty或者(*iter).empty  
//      (d) iter->empty();    合法。判断迭代器所指元素是否为空  
//      (e) ++*iter;    非法。同(b)
//      (f) iter++->empty();    合法。先返回iter->empty，再iter++

//4.21   编写一段程序，使用条件运算符从vector中找到哪些元素的值是奇数，然后将这些奇数值翻倍。
//解：
// #include<iostream>
// #include<vector>

// using std::cout;
// using std::endl;
// using std::vector;

// int main()
// {
// 	vector<int> ivec{ 1, 2, 3, 4, 5 };
// 	for (auto &i : ivec)
// 	{
// 		cout << (((i % 2) == 0) ? i : i * 2) << " ";
// 	}
// 	cout << endl;
// 	return 0;
// }

//4.22   本节的示例程序将成绩划分为high pass、pass 和 fail 三种，扩展该程序使其进一步将 60 分到 75 分之间的成绩设定为low pass。
//       要求程序包含两个版本：一个版本只使用条件运算符；另一个版本使用1个或多个if语句。哪个版本的程序更容易理解呢？为什么？
//解：
// #include <iostream>

// using std::cin;
// using std::cout;
// using std::endl;

// int main()
// {
//     unsigned grade;
//     cin >> grade;

//     auto result = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : (grade < 75) ? "low pass" : "pass";
// 	cout << result << endl;
//     //首先用 ? : 排除 > 90 和 < 60 的部分，再判断75。
//     // -------------------------
//     if (grade > 90)         
//         cout << "high pass";
// 	else if (grade < 60)    
//         cout << "fail";
// 	else if (grade < 75)    
//         cout << "low pass";
// 	else                
//         cout << "pass";
// 	cout << endl;
// 	return 0;
// }

// //      第二个版本容易理解。? : 嵌套层数变多，使代码难以读懂。而if-else结构更为清晰。

//4.23   因为运算符的优先级问题，下面这条表达式无法通过编译。根据4.12节中的表指出它的问题在哪里？应该如何修改？
//       string s = "word";
//       string pl = s + s[s.size() - 1] == 's' ? "" : "s" ;
//解：
//      首先计算了s[s.size() - 1]并将其与's'比较作为cond来执行?:语句。
//      我们可知'd' ！= 's'，因此需要将s和's'连接。由于?:运算符优先级低于 + 运算符，因此加上括号。
//      string pl = s + (s[s.size() - 1] == 's' ? "" : "s") ;

//4.24  本节的示例程序将成绩划分为high pass、pass、和fail三种，它的依据是条件运算符满足右结合律。
//      假如条件运算符满足的是左结合律，求值的过程将是怎样的？
//解：
//      如果满足左结合律。那么原语句
//      finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
//      等同于 finalgrade = [(grade > 90) ? "high pass" : (grade < 60)] ? "fail" : "pass";
//      此时第一个 ?: 运算符会把 grade 和 60 的对比语句作为第一层内的语句。
//      假如此时 grade > 90 ，第一个条件表达式的结果是 "high pass" ，非空所以为真。
//      因此第二个条件表达式的结果是 "fail"。出现了逻辑问题。
