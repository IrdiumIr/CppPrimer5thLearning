# Ch10 泛型算法

## 10.1 概述
* 1.算法基本定义在头文件`algorithm`中，数值算法也在`numeric`中有涉及
* 2.大多数算法是通过遍历两个迭代器标记范围来实现其功能，而不直接操作容器
* 3.算法依赖元素类型的操作，但是大多数算法允许使用自定义操作符重载默认操作符以使得其支持此运算
* 4.算法永远不会改变容器大小：可能改变值，也可能移动元素，但是不直接添加/删除元素

## 10.2 初识泛型算法
* 这些算法基本有一致的结构，使用两个参数来表示输入范围；理解的基本方法是了解它们是否读取、改变、重排元素顺序

### 10.2.1 只读算法
* 1.只读算法只读取迭代器范围中的元素而不改变它
* 2.例如`find`.`count`和`accumulate`(`numeric`)
* 3.`accumulate`的第三个参数类型决定了函数使用何种`+`来进行运算
* 4.`equal`算法操作两个序列判断是否保存了相同的值，包括此类只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少和第一个一样长
* 5.只读算法通常使用`cbegin`.`cend`

### 10.2.2 写容器元素的算法
* 1.向容器中写入元素时，必须保证原容器大小至少不小于写入元素的数量
* 2.算法不检查写入操作
* 3.`fill`和`fill_n`会在容器迭代器指定位置处插入元素；而需要注意`fill_n`必须保证从迭代器开始的位置容器有`n`个元素，而不能对空容器使用`fill_n`
* 4.插入迭代器`back_inserter`并不直接将值赋予其指向的元素，而是将`=`右侧相等的值作为一个新元素添加到容器中，相当于调用了`push_back`
* 5.插入迭代器保证了算法有足够的空间存储数据，通常用其来创建迭代器，作为算法的作用目的位置使用
* 6.拷贝算法`copy`接受两个迭代器作为输入范围，第三个迭代器作为写入序列的起始位置。需要保证目标序列的大小至少和输入范围一样大
* 7.`copy`可以实现内置数组的拷贝，且能够返回尾后迭代器
* 8.有拷贝`copy`版本的算法通常不直接放到输入序列的末尾，而是新建一个序列来保存结果

### 10.2.3 重排容器元素的算法
* 1.重排算法会重排容器中元素的顺序，例如`sort`是利用元素类型的`<`运算符实现的
* 2.`sort`接受范围为输入范围的迭代器，将此范围内元素按字典序重排
* 3.`unique`再次重排了输入范围，将此部分的重复元素“消除”了（实际上并未删除），只是并不知道这些值是什么
* 4.实际的删除操作并不能使用算法，而是需要使用和容器关联的操作

## 10.3 定制操作
* 算法在比较输入范围的元素时，有时需要重载函数的默认行为：例如`sort`是以元素类型的`<`排序，但可能我们希望的顺序与此不同，或元素类型并未定义`<`运算符

### 10.3.1 向算法传递函数
* 1.谓词是一个可调用的表达式，作为算法的第三个参数；返回结果是一个能作为条件的值；谓词根据能够接收的参数的数量分为一元谓词和二元谓词
* 2.同样的，由于接受谓词参数的算法对输入序列内的元素调用谓词，因此序列内的元素类型必须能够转换为谓词的参数类型
* 3.`stable_sort`算法维持相等(`isShorter`定义的有相同长度)元素的原有顺序

### 10.3.2 lambda表达式
* 1.当需要算法的谓词接受更多参数时，往往受限于格式
* 2.`lambda`表达式是一个可调用的对象：使用调用运算符`()`，可以理解为一个未命名的`inline`函数
* 3.基本形式为：`[capture list](parameter list) -> return type {function body}`
  * `capture list`捕获列表是`lambda`所在函数定义的局部变量的列表(通常为空)且不可忽略。
  * 其他三部分类似函数体
  * 返回类型必须使用尾置返回
* 4.`lambda`能够自动推断返回类型：若函数体包含任何非单一`return`之外的内容且未指定返回类型，则返回`void`
* 5.`lambda`不能有默认参数，实参和形参的数目必须相等
* 6.捕获列表只用于局部的、非`static`对象；`lambda`可以直接使用所在函数体外声明的对象

### 10.3.3 lambda捕获和返回
* 1.定义`lambda`时会生成一个新的类类型和该类型的一个对象(未命名)
* 2.从`lambda`生成的类也会包含`[]`内捕获的变量的数据成员，且在`lambda`对象创建时被初始化
* 3.变量的捕获形式有值/引用两种
* 4.值捕获的前提是变量可以拷贝，且变量值在`lambda`创建时即拷贝，而非调用时。因此之后的修改不会影响到`lambda`
* 5.引用捕获与之前的引用传递类似，使用的实际是引用绑定的对象。因此必须保证在`lambda`执行时，变量是存在的
* 6.函数返回`lambda`的情况下，此`lambda`不能包含引用捕获：类似函数不能返回局部变量的`&`
* 7.因此，尽量减少捕获的数据量，且尽可能避免捕获指针或引用
* 8.隐式捕获通过在`[]`中写`&`或`=`来让编译器推断得出捕获列表
* 9.显式/隐式捕获可以混合使用，但是使用符号的隐式必须在前面；同时显式捕获变量必须与隐式的不同
* 10.可变`lambda`可以改变通过值捕获的对象的值(原本不变)，通过在参数列表首加上`mutable`关键字以实现
* 11.`lambda`的返回类型通过尾置返回类型`->`来实现

### 10.3.4 参数绑定
* 1.`lambda`表达式更适合只使用少数几处的简单操作
* 2.使用函数通常可以实现和`lambda`表达式相同的功能，但是不能解决接受谓词时对于传递参数数量的影响
* 3.标准库`bind`函数定义在头文件`functional`中，可以看成一个通用的函数适配器
* 4.`bind`接受一个可调用对象，生成一个新的可调用对象以适应参数列表
* 5.在调用新的可调用对象时，对调用旧的可调用对象，并且将`args`传递给它，且`_1`.`_2`代表了传递参数`args`的位置
* 6.`_n`定义在`std`定义的`placeholders`的命名空间中，例如`using namespace std::placeholders`
* 7.使用`bind`的参数会根据占位符`_n`的数字顺序来传递给调用的旧对象。因此可以通过这一特性来重排参数顺序
* 8.`bind`的参数列表如果要获取一个非占位符`_n`的参数且需要使用引用(或者无法拷贝)，必须使用标准库的`ref`或`cref`函数

## 10.4 再探迭代器
* 迭代器除了每个容器定义通用的迭代器之外，还定义了插入迭代器、流迭代器、反向迭代器和移动迭代器

### 10.4.1 插入迭代器
* 1.插入迭代器是一种迭代器适配器。接受一个容器，生成一个迭代器，能实现向给定容器添加元素。给其赋值时，会调用容器操作向指定容器的指定位置插入元素
* 2.插入迭代器有三种类型，区别在于插入位置
  * 1.`back_inserter`创建了一个使用`push_back`的迭代器
  * 2.`front_inserter`创建了一个使用`push_front`的迭代器
  * 3.`inserter`创建一个使用`insert`的迭代器，接受第二个参数(一个指向给定容器的迭代器，插入到指向元素之前)
* 3.`front_inserter`和`inserter`的不同在于：前者会在序列开头将元素的顺序颠倒(每次插入后`begin`会更新)，而后者确定位置后不再改变

### 10.4.2 `iostream`迭代器
* 1.虽然迭代器需要绑定到容器上，但是标准库还是定义了可以用于IO对象的迭代器。它们与输入输出流绑定在一起，用于遍历关联的IO流
* 2.istream_iterator<Type> t(is)作为流迭代器的定义，构造时可直接从输入流`is`读取数据
* 3.流迭代器能够支持部分迭代器操作，因此部分算法可以操作流迭代器，例如`accumulate`
* 4.`ostream_iterator`在创建时可以增加第二个参数，是一个`cstring`，在每次输出值后会再多输出一个字符数组
* 5.`ostream_iterator`必须绑定到一个指定的流，而不能像`istream_iterator`一样初始化为空或表示尾后位置`eof`
* 6.`*`.`++`对`ostream_iterator`实际上是无效的，但是通常在写的时候不省略，为了保持与其他迭代器以及`istream_iterator`保持一致方便理解

### 10.4.3 反向迭代器
* 1.反向迭代器就是在容器中从尾至首反向移动的迭代器，其递增递减操作的含义将颠倒
* 2.除了`forward_list`外的容器都支持反向迭代器，因此都可以通过`rbegin`和`rend`来进行反向遍历
* 3.除了可以通过`bind`重排参数来改变算法含义，还能通过给算法传递反向迭代器来实现其他功能
* 4.流迭代器不支持递减运算，也就不支持反向迭代
* 5.`reverse_iterator`有`base()`成员函数，能够将反向迭代器转变回正常顺序的迭代器，从而实现正确顺序的遍历；但是并不指向相同的位置。这是为了保证左闭合区间指向相同的元素范围而造成的

## 10.5 泛型算法结构
* 每个算法都会对每个迭代器操作指明提供何种迭代器
* 分别分为：输入迭代器、输出迭代器、前向迭代器、双向迭代随机访问迭代器

### 10.5.1 5类迭代器
* 1.高层类别的迭代器支持底层迭代器所有的操作
* 2.算法的迭代器参数有其最小类别：传递了更低层的迭代器将会导致操作失败，但不会报错
* 3.输入迭代器：只读不写，单遍扫描只能递增；可右侧解引用
* 4.输出迭代器：只写不读，单遍扫描只能递增；只能左侧解引用写入
* 5.前向迭代器：可读写，多遍扫描只能递增；可多次读写同一元素
* 6.双向迭代器：可读写，多遍扫描递增递减；还支持`--`
* 7.随机访问迭代器：可读写，多遍扫描支持全部运算；支持下标`[n]`和复合增减`+=`.`-=`

### 10.5.2 算法形参模式
* 1.`dest`参数用于表示算法可以写入的目的位置的迭代器。假定需要在此位置写入时，写入多少都是安全的
* 2.通常情况下，`dest`是绑定到插入迭代器，或者是一个`ostream_iterator`，因为这两者都能保证写入空间足够
* 3.`beg2`.`end2`参数通常用于接受算法的第二个输入范围；接受单独`beg2`的算法默认从此开始的序列大小至少和`[beg, end)`一样大

### 10.5.3 算法命名规范
* 1.一些算法使用重载形式传递一个谓词
* 2.接受一个元素值的算法通常有一个不同名的版本：加`_if`，接受一个谓词代替元素值
* 3.区分拷贝元素的版本和不拷贝的版本，拷贝版本通常加`_copy`

## 10.6 特定容器算法
* 1.链表`list`和`forward_list`与其他容器不同，其定义了若干个成员函数形式的算法，而非泛型的
* 2.定义了特有的`sort`.`merge`.`remove`.`reverse`和`unique`
* 3.链表特有的`splice`成员函数算法
* 4.链表的特有版本算法通常会改变容器本身，而不是类似泛型算法只操作迭代器而不改变容器