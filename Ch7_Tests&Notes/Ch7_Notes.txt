Ch7 类

7.1 定义抽象数据类型
    基本思想：数据抽象(接口和实现分离)和封装。
    接口：用户所能执行的操作；实现：类的数据成员、实现接口的函数体和定义类的私有函数。
    类成员：必须在类的内部声明，不能在其他地方增加成员。成员可以是数据，函数，类型别名。
    类的成员函数：
        成员函数的声明必须在类的内部。定义既可以在类的内部也可以在外部。
        使用点运算符.调用成员函数。
        调用某成员函数时，实际上是代替某个对象调用。(isbn返回bookNo实际上是返回total.bookNo)
        隐式形参this：
            每个成员函数都有一个隐含的形参this。this总是指向当前对象，因此this是一个常量指针，无法改变地址。
            形参表后面的const，改变了隐含的this形参的类型，这种函数称为“常量成员函数”，表示这是指向常量的指针。
            return *this返回调用该函数对象
        普通的非const成员函数：this是指向类类型的const指针（可以改变this所指向的值，不能改变this保存的地址）。
        const成员函数：this是指向const类类型的const指针（既不能改变this所指向的值，也不能改变this保存的地址）。
    非成员函数：和类相关的非成员函数，定义和声明都应该在类的外部。
    类的构造函数:
        类通过特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。
        构造函数是特殊的成员函数，名字和类名相同，没有返回类型，且不能被声明为const。
        构造函数放在类的public部分。
        合成的默认构造函数：存在类内初始值，则初始化成员；否则默认初始化成员。(未声明任何构造函数时，才自动生成)
        = default 要求编译器合成默认的构造函数。
        Sales_data (const string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n) { }
        冒号前后分别对应进行初始化，如果构造函数内参数缺省，则会使用默认合成构造函数进行隐式初始化。
        函数体为空：除了赋初始值，没有其他任务需要执行。
    其余操作：拷贝、赋值和析构
        类需要控制拷贝、赋值以及销毁对象时发生的行为。

7.2 访问控制与封装
    访问说明符：public/private
        public后的成员在整个程序内可被访问，用于定义程序接口；->构造函数和成员函数
        private后的成员仅可被此类的成员函数访问，不能被使用类的函数访问。->数据成员和成员函数
    class/struct？
        在首个访问符之前定义的成员默认访问权限有所不同
        使用struct，在首个访问符之前是public的；class则是private的。
    友元
        允许其他类/函数访问一个类的private成员。
        一般在类定义的开始或者结尾集中地，以friend开头对于需要作为友元的函数进行[再次]声明即可。

7.3 类的其他特性
    类成员
        类可以在类内定义某种类型的别名，同时可用public/private修饰
        类型成员先定义后使用，出现在开头。using A = B / typedef B A; A作为B别名
        类内部小规模的成员函数自动inline，外部定义可在声明时inline，也可在定义时inline。
        可变数据成员：mutable作为关键字。任何成员函数（包括const成员函数）都可以改变其值。
    *this成员函数
        返回*this的成员函数，返回值是调用该成员函数的对象的引用&。说明返回了对象本身而非副本。
        若成员函数为const，this为指向const的指针，而*this是const对象。
        当返回const对象的引用时，实际上无法对其进行修改。(P248隐式传递this指针-重载)
    类类型
        每个类定义了唯一的类型。不同类之间的成员完全不同。
        类的声明：前向声明(不完全声明)
    友元
        类内可以将其他类定义为友元类。class A { friend class B; }
        友元不具有传递性。
        也可单独将某个成员函数定义为友元，但需要指出属于哪个类(::)。且需要设计程序结构关系。
        友元声明仅仅是影响访问权限，并非普通意义的声明。

7.4 类的作用域
    每个类都会定义它自己的作用域。在作用域之外，普通成员只能由引用、对象、指针使用成员访问运算符来访问。
    函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
        如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。
        [返回类型为定义的成员，需要明确作用位置]
    类中的类型名定义都要放在一开始。

7.5 构造函数
    const或者引用类型的数据，必须初始化，不能赋值。成员初始化顺序和类定义中一致，而与初始值列表无关。
    但是最好让构造函数初始值的顺序和成员声明的顺序保持一致，并且避免用成员初始化成员。
    如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。
    委托构造函数
        委托构造函数将职责委托给了其他构造函数。Sale_data(): Sale_data("", 0, 0) {}
    默认构造函数：Sales_data obj1()……×  Sales_data obj2……√
    隐式的类型转换：构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。(转换构造函数)
        编译器只会自动地执行仅一步类型转换。Sales_data string "999"
        explicit 声明构造函数以阻止隐式转换，且explicit只能用于直接初始化，不能用于拷贝形式初始化。
        string非explicit，vector为explicit。
    聚合类：
        所有成员都是public的。
        没有定义任何构造函数。
        没有类内初始值。
        //没有基类，也没有virtual函数。
        可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。
    字面值常量类：数据成员都是字面值类型的[聚合类]->constexpr函数的参数和返回值必须是字面值。
        如果不是聚合类，则必须满足下面所有条件：
        数据成员都必须是字面值类型。
        类必须至少含有一个constexpr构造函数。(constexpr是隐式const的)
        如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；
            或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
        类必须使用析构函数的默认定义，该成员负责销毁类的对象。

7.6 类的静态成员
    static数据成员是与类关联的对象，并不与该类的对象相关联。
    非static数据成员存在于类类型的每个对象中。
    static数据成员独立于该类的任意对象而存在。
    声明：
        声明之前加上关键字static。
    使用：
        使用作用域运算符::直接访问静态成员:r = Account::rate();
        也可以使用对象、引用、指针访问：r = ac.rate();
    定义：
        在类外部定义时不加static，static只出现在类内部的声明语句。
    初始化：
        通常不在类的内部初始化，而是在定义时进行初始化，如 double Account::interestRate = initRate();
        如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr。此后同样需要在类外部定义一次。
    