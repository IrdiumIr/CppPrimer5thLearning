# Ch9 顺序容器

## 9.1 顺序容器概述
* 1.`deque`双端队列(double-end-queue)可访问下标，头尾速度快
* 2.`list`(forward_)链表只支持顺序访问，可在任何位置操作
* 3.容器的选择依赖于性能的考虑(何种操作更多)

## 9.2 容器库概览
* 1.容器操作与类型相关，定义在头文件`<vector>.<list>`等中，需要提供元素类型信息
* 2.容器操作见**Chart9.2,P295**
* 3.元素类型，左值类型，const左值类型

### 9.2.1 迭代器
* 1.`forward_list`迭代器不支持`--iter`(单向)
* 2.迭代器的算术运算只对`string`.`vector`.`deque`和`array`适用
* 3.迭代器的范围是一个左闭合区间`[begin,end)`，`end`是尾后元素
* 4.若`begin=end`则范围为空；不等的情况下`begin`可递增到`end`

### 9.2.2 容器类型成员
* NULL

### 9.2.3 `begin`和`end`成员
* 1.不以`c`开头的成员是重载后的
* 2.`auto`和`begin`.`end`结合使用的情况下，迭代器类型依赖于容器类型；使用`cbegin`和`cend`可以直接获取`const_iterator`
* 3.不进行写操作时，尽量使用`cbegin`和`cend`

### 9.2.4 容器定义和初始化
* 1.除了`array`外的容器，默认构建空容器
* 2.只有顺序容器的构造函数才接受大小参数，关联容器并不支持
* 3.容器拷贝时，容器类型和元素类型都需要匹配；然而使用迭代器复制则无此要求
* 4.内置类型或有默认构造函数的类类型可只提供容器大小参数`n`；否则需指定显式初始值
* 5.标准库`array`和内置数组一样，需要尺寸大小`n`：`array<int, n>`
* 6.内置数组不能进行拷贝和赋值操作；而`array`可以

### 9.2.5 赋值和`swap`
* 1.`assign`操作不适用于关联容器和`array`，因为左右运算对象大小可能不同
* 2.`swap`的效率通常比拷贝快得多
* 3.`assign`的迭代器参数不能指向调用的对象，因为旧元素会被替换
* 4.赋值运算会导致容器的迭代器、引用和指针失效；而`swap`操作不会导致除了`array`和`string`外的容器失效:`swap`前后指向不变，但是元素属于的容器改变了
* 5.请统一使用非成员版本的`swap`：`swap(a, b)`
* 6.对`array`使用`swap`会真正交换两个数组的元素，因此时间和数组大小成正比

### 9.2.6 容器大小操作
* 1.`forward_list`不支持`size`获取元素数量

### 9.2.7 关系运算符
* 1.容器的比较实际上是容器内元素的逐对比较
* 2.容器都支持相等运算符(`=`和`!=`)，除无序关联容器之外都支持关系运算符(`>`.`<`.`≥`.`≤`)
* 3.容器的比较实际上是使用元素的关系运算符完成比较(元素类型不支持情况下，容器无法进行运算)

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素
* 1.非`array`的顺序容器都能够动态的添加或删除元素：改变容器大小的操作不适用于`array`
* 2.`forward_list`不支持尾部插入`push_back`和`emplace_back`，且有专属的`insert`和`emplace`
* 3.`vector`和`string`不支持`push_front`和`emplace_front`
* 4.容器元素是对象的拷贝：类似于将对象传递给非引用参数
* 5.`push_front`最终在开头形成逆序
* 6.`insert`是更一般的插入操作，且接收的参数`args`类似构造函数，可以接受更多
* 7.`insert`返回新迭代器`p'`，若范围为空则返回原迭代器`p`
* 8.`insert`可在一个位置反复插入元素：`while(cin >> word) {iter = lst.insert(iter, word);}`
* 9.`emplace`相关操作是构造而不是和`push`.`insert`相似的拷贝元素，因此传递参数必须和元素类型的构造函数匹配

### 9.3.2 访问元素
* 1.空容器的访问元素的行为是`UB`的
* 2.`front`适用于所有顺序容器，而`back`不适用于`forward_list`
* 3.`at`和下标随机访问元素不适用于链表容器`list`和`forward_list`
* 4.访问成员函数返回的是引用，需要自己定义`&`
* 5.使用`at(n)`可以避免下标的不合法，抛出错误

### 9.3.3 删除元素
* 1.和**9.3.1**类似，删除/添加元素的操作会改变容器大小，因此不适用于`array`
* 2.`forward_list`不支持尾部删除`pop_back`，且有专属的`erase`
* 3.`vector`和`string`不支持`pop_front`
* 4.删除`deque`中间元素会使其失效；删除`vector`.`string`点后的迭代器将失效
* 5.`pop`操作返回`void`，因此需要提前保存
* 6.`erase`函数返回删后的迭代器，和`insert`返回插入前位置的迭代器类似理解

### 9.3.4 特殊的`forward_list`操作
* 1.单向链表`forward_list`无法访问所修改的元素的前驱，因此不能使用通常的`insert`.`emplace`.`erase`等操作，因为这通常会改变元素之间链接的关系
* 2.`before_begin`迭代器是首前迭代器，返回指向链表首元素之前那个不存在的元素的迭代器，类似尾后迭代器
* 3.`xx_after`返回类型为指向新增加的/删除的元素的迭代器
* 4.`forward_list`操作时必须关注两个迭代器：分别是要操作的元素和其前驱

### 9.3.5 改变容器大小
* 1.`resize`缩小容器会导致被删除元素的迭代器失效
* 2.对非链表容器进行`resize`可能导致迭代器等失效

### 9.3.6 容器操作可能使迭代器失效
* 1.添加元素：
  * 1.`vector`.`string`是否失效取决于存储空间是否重新分配：若重新分配后，则都会失效；若存储空间未重新分配，则插入位置之前仍然有效
  * 2.`deque`非首尾位置会导致失效；首尾位置添加只会导致迭代器失效，而已存在的元素的引用和指针不会失效
  * 3.链表不受影响
* 2.删除元素：
  * 1.`vector`.`string`被删元素之前依然有效
  * 2.`deque`删除首尾之外的元素时，指向非被删除元素的迭代器等均失效；删除尾元素只会导致尾后迭代器失效；删除首元素则不受影响
  * 3.链表对于非被删除元素的迭代器等都不受影响
  * 4.尾后迭代器总是失效
  * 5.不要返回`end`返回的迭代器，在循环中每次重新调用`end`

## 9.4 vector对象是如何增长的
* 1.`vector`和`string`在内存中连续保存，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素移动到新空间中，然后添加新元素，释放旧空间。(在分配新空间时通常多分配一些以提高效率)
* 2.`capacity`和`reverse`只适用于`vector`和`string`；`shrink_to_fit`还适用于`deque`
* 3.只有迫不得已，即类似`insert`时`size`与`capacity`相等；或使用`resize`和`reverse`给定大小超过当前`capacity`时，才会多分配内存空间(一般是当前翻倍)

## 9.5 额外的`string`操作

### 9.5.1 构造`string`的其他方法
* 1.`n`.`len2`.`pos2`都是无符号值
* 2.接受`string`或`cosnt char*`参数和字符数的参数
* 3.从`const char*`创建`string`时，数组必须以空字符结尾
* 4.`substr`最多只会拷贝到`string`的末尾

### 9.5.2 改变`string`的其他方法
* 1.`string`中特有的使用下标的`insert`.`erase`和`assign`方法，返回引用对象`s`的引用而非迭代器
* 2.`append`是在`string`末尾进行插入操作的简写方法，返回`s`的引用
* 3.`replace`是在`string`中调用`erase`和`insert`的复合简写方法；删除的和新插入的可以不等长度

### 9.5.3 `string`搜索操作
* 1.`string`类提供了6个不同的搜索函数，各自有4个重载版本
* 2.返回值为`string::size_type`，表示匹配位置的下标
* 3.搜索失败返回`string::npos`的`static`成员(类型是`string::size_type`，初始化为-1，也就是`string`最大的可能大小)
* 4.逆向搜索`rfind`.`find_last_of`

### 9.5.4 `compare`函数
* 1.`compare`类似`<cstring>`的`strcmp`函数，根据字符串的比较返回一个正/负数

### 9.5.5 数值转换
* 1.一个数的字符通常不等于其数值
* 2.转换数值的`string`第一个非空白符必须是数值可能出现的字符(±或数字)
* 3.`to_string()`和`stoi/l/f/d`等参数列表里的下标指针`p`和基数`b`都可省略

## 9.6 容器适配器
* 1.适配器接受容器类型参数，使其以另一种类型的方式工作
* 2.容器、函数、迭代器都有适配器
* 3.初始化`deque<int> deq; stack<int> stk(deq);` 从`deq`拷贝元素到`stk`
* 4.默认情况下，`stack`和`queue`是基于`deque`实现的；而`priority_queue`是基于`vector`实现的
* 5.适配器不能使用`array`和`forward_list`容器，因为其要求能够添加、删除以及访问尾元素
* 6.`stack`可基于以上的容器实现；`queue`由于需要`front`，因此只能基于`list`.`deque`；`priority_queue`需要随机访问，因此只能基于`vector`.`deque`
* 7.适配器是基于容器定义的，但是只能使用本身的操作，而不能使用底层容器类型的操作：例如`stack`只能使用`push`而不能使用`push_back`
* 8.`queue`是先进先出(FIFO)的，而`priority_queue`是优先队列