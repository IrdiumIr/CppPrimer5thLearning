Ch6 函数

6.1 函数基础
    函数定义：包括->返回类型、函数名、0/多个形参（parameter）组成的列表、函数体。
    调用运算符：调用运算符的形式是一对圆括号 ()。作用于一个表达式，该表达式是函数或者指向函数的指针。
    圆括号内是用逗号隔开的[实参]（argument）列表。
    函数调用过程：(实参初始化形参；控制权转移给被调函数)
        1.主调函数（calling function）的执行被中断。
        2.被调函数（called function）开始执行。
    形参和实参：实参是形参的初始值。形参和实参的个数和类型必须匹配。形参可以为空，但不同形参需要使用逗号隔开。
    返回类型： void表示函数不返回任何值。函数的返回类型不能是数组或者函数，但可以是指向两者的指针。
    名字：名字的作用于是程序文本的一部分，名字在其中可见。
    局部对象
        生命周期：对象的生命周期是程序执行过程中该对象[存在]的一段时间。周期依赖于定义方式。
        局部变量（local var）：定义在形参和函数体内部的变量。对函数外部而言是隐藏的。
        自动对象：只存在于块执行期间的对象。当块的执行结束后，值就变成未定义(形参)。
        局部静态对象： static类型的局部变量，生命周期贯穿函数调用及之后。
    函数声明
        函数声明：函数的声明无需函数体，用一个分号替代。函数声明主要用于描述函数的[接口]，也称函数原型。
        建议函数在头文件中声明；在源文件中定义。可以保证同一函数的声明保持一致，只需改变声明即可改变所有函数的接口。
        分离编译：
            CC a.cc b.cc直接编译生成可执行文件；
            CC -c a.cc b.cc编译生成对象代码a.o b.o；
            CC a.o b.o编译生成可执行文件。

6.2 参数传递
    引用传递：又称传引用调用，形参是引用类型，引用形参是它对应的实参的别名。
    值传递：又称传值调用，实参的值通过拷贝传递给形参。类似于拷贝形式的初始化
    传值参数：
        当初始化一个非引用类型的变量时，初始值被拷贝给变量。函数对形参做的所有操作都不会影响实参。
        指针形参：常用在C中，C++建议使用引用类型的形参代替指针。
    传引用参数
        引用形参直接关联到绑定的对象P，直接传入对象而非地址。
        使用引用形参可以避免不必要的复制。(低效或不支持)
        使用引用形参可以用于返回多个值，通过传入额外的引用实参的形式。
        如果无需改变引用形参的值，最好将其声明为常量引用。
    const形参和实参
        形参的顶层const被忽略。void func(const int i);调用时既可以传入const int也可以传入int。
        我们可以使用非常量初始化一个底层const对象，反之不行。
        在函数中，不使用const会限制传入实参的范围，尽量使用常量引用。
    数组形参
        当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
            通常使用标记、标准库规范(begin/end)和传递数组大小形参、数组引用形参。P194
        要注意数组的实际长度，不能越界。
    main处理命令行选项
        int main(int argc, char *argv[]){...}。第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。
        argv第一个元素指向程序名，后续依次传递实参。
    可变形参：P197
        数量未知，类型都相同：initializer_list类型形参。(和vector一样的模板类型，但其元素永远是const)
        类型不相同：编写可变参数模板
        省略形参符：...，便于C++访问某些C代码，使用了varargs的C标准功能。

6.3 返回类型和return语句
    return语句终止当前正在执行的函数并返回调用该函数的地方。return;/return expression。
    无返回值函数：只能用在返回类型为void函数中(甚至不加return：隐式执行return)：return也可以用于提前退出。
    有返回值函数：
        return语句的返回值的类型必须和函数的返回类型相同，或者能够隐式地转换成函数的返回类型。
        值的返回：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。不要返回局部对象的引用或指针。
        引用返回左值：函数的返回类型决定函数调用是否是左值。
            调用一个返回引用的函数得到左值；其他返回类型得到右值，返回常量引用无法赋值。
        列表初始化返回值：函数可以返回花括号包围的值的列表。（C++11）
            返回内置类型则{}最多包括一个值；返回类类型则由类本身定义。
        主函数main返回值：如果结尾没有return，编译器将隐式地插入一条返回0的return语句。返回0代表执行成功。
            返回预处理变量：<cstdlib> EXIT_FAILURE/SUCCESS
    返回数组指针
        Type (*function (parameter_list))[dimension]，没有括号将返回含有dimension个指针的数组
        使用类型别名： typedef int arrT[10]; 或者 using arrT = int[10;]，然后 arrT* func() {...}
        尾置返回类型： 在形参列表后面以一个->开始：auto func(int i) -> int(*)[10]（C++11）
        使用 decltype： decltype(odd) *arrPtr(int i) {...}

6.4 函数重载
    重载：同一作用域内几个函数名字相同但形参列表不同，编译器将自动根据传递实参类型选择函数；main函数不能重载。
        不允许两个函数除了返回类型之外都相同；省略形参名字并不影响两个函数是否相同。
    重载和const形参：
        一个有[顶层]const的形参和没有它的函数无法区分。
        相反，是否有某个[底层]const形参可以区分。形参若是某种类型的指针或引用，通过指向常量/非常量对象进行重载。
    函数匹配：最佳匹配、无匹配、二义性调用。
    重载和作用域：在不同的作用域中无法重载函数名。若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。

6.5 特殊用途语言特性
    默认实参：多次调用中赋值相同
        string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
        一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。
        调用函数时省略实参，将会自动使用默认实参，默认填补缺省的部分。(尽量靠后)
    内联（inline）函数
        普通函数的调用时比求解等价表达式要慢得多。
        inline函数可以避免函数调用的开销，可以让编译器在编译时内联地展开该函数；通常在头文件中定义。
    constexpr函数：指能用于常量表达式的函数。
        函数的返回类型及所有形参类型都要是字面值类型；且有且只能有一条return。
        constexpr函数应该在头文件中定义。
    调试帮助
        assert预处理宏：assert(expr);为真则不做操作，为假则输出信息并终止程序执行。
    
6.6 函数匹配
    重载函数匹配的三个步骤：1.候选函数；2.可行函数；3.寻找最佳匹配。
    候选函数：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
    可行函数：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
    寻找最佳匹配：实参类型和形参类型越接近匹配越好。1.精确匹配；2.const转换匹配；3.类型提升匹配；4.算术转换/指针转换匹配；5.类类型转换

6.7 函数指针
    函数指针：是指向函数的指针。只需将函数名换成指针即可。在调用函数指针时，是否使用取地址&或者解引用*都是可行的。
    函数指针形参：形参中使用函数定义或者函数指针定义效果一样。
        使用类型别名或者decltype可以简化函数指针代码。
    返回指向函数的指针：1.类型别名；2.尾置返回类型。
        int (*f1(int)) (int*, int);
        auto f1(int) -> int (*)(int*, int)