Ch2 变量和基本类型

2.1 基本内置类型
    主要包括算术类型和空类型。算术类型包括整型(字符和bool)以及浮点型。
    常见的类型大小从小到大分别有：bool/char(8),short/int(16),long(32),folat/double(6/10位数字)等。P30
    确定数值不为负时尽量使用unsigned类型，浮点数运算时候使用double。
    类型转换：
        unsigned得到一个超出范围的值，结果为对unsigned总数取模后的[余数]；signed则会UB。
        尽量不在算术式中使用bool值，并且避免混用unsigned和signed类型。避免出现未定义行为(UB)。
        int和unsigned运算，int会转化为unsigned
    字面值常量：一望而知的值。
        整型和浮点型字面值
        字符和字符串字面值：''和""，可以通过空格连接。(字符串类字面值以\0结尾，长1位) ->常量字符构成的数组
        转义字符序列：\n,\t等；前后缀P37可改变默认类型。

2.2 变量
    变量提供一个具名的、可供程序操作的存储空间。 C++中变量和对象一般可以互换使用。
    变量定义：
        定义形式：类型说明符 + 一或多个变量名列表。
        初始化：对象在创建时获得了一个特定的值。(与赋值不同)
        初始化 = 创建变量 + 赋予初始值
        赋值 = 擦除对象的当前值 + 用新值代替
        列表初始化：使用花括号 { }，存在风险时可能会报错。
        默认初始化：内置类型定义时没有指定初始值会默认初始化；在函数体内部的将不会被初始化。
    变量的声明与定义
        为了支持分离式编译，C++将声明和定义区分开。声明使得名字为程序所知。定义负责创建与名字关联的实体。
        只声明而不定义： 在变量名前添加关键字 extern。若初始化则声明无效。
        变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。
    名字的作用域：最好第一次使用变量时再定义它.
        同时存在全局和局部变量时，已定义局部变量的作用域中可用::name显式访问全局变量name。(全局作用域没有名字)
    变量命名规范：
        需体现实际意义；变量名用小写字母；自定义类名用大写字母开头；标识符由多个单词组成，中间须有明确区分。

2.3 复合类型：声明符基于基本类型得到更复杂的类型
    引用：
        引用是一个对象的[别名]，引用类型引用另外一种类型，使用&符号定义，且必须初始化。
        引用和它的初始值是绑定在一起的，而不是拷贝。一旦定义就不能更改。
        引用只能和对象绑定，而不能和字面值等进行绑定。
    指针：
        是一种 "指向"另外一种类型的复合类型，本身就是一个对象，因此并非必须初始化。
        定义指针类型：int *p;，从右向左读有助于阅读，p是指向int类型的指针。指针不能指向引用
        指针存放某个对象的地址，即指针的值就是地址。
        &是取地址符; *是解引用符。
        指针的类型与所指向的对象类型必须一致，空指针(不指向任何对象)使用nullptr，不能使用0！
        指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象；指针并没有此限制，相当于变量一样使用。
        void*指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。
    复合声明：
        *和&通常与变量名相联。
        指向指针的指针：int **ppi = &pi(int *pi = &ival)
        指向指针的引用：引用不是对象，所以不存在指向引用的指针。
            但是指针是对象，因此存在对指针的引用。
            int *p; int *&r = p;

2.4 const限定符
    对于一部份不希望被改变的值，进行限定。
    初始化和const
        const对象必须初始化，且不能被改变。仅在单文件内有效。
        const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern，声明时也加extern。
    const的引用
        对常量的引用：指向const对象的引用，可以读取但不能修改。
            非常量引用指向常量……× int &r2 = ci(const int ci)
            常量引用绑定非常量……√
        临时量对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。不能对临时量进行引用。
        对const的引用可能是非const对象，只是限定了引用本身的[操作]。引用的对象本身是不是const不限定。
    指针和const
        指向常量的指针：不能用于改变其所指对象的值。(和对const的引用类似)
            类似与const引用，指向常量的指针也可以绑定非常量。-> “自以为是”
        常量指针const pointer：指针本身是常量，也就是说指针固定指向该对象，必须初始化。
            (存放在指针中的地址不变，地址所对应的那个对象值可以修改)。
    顶层/底层const
        顶层const：指针本身是个常量。不影响拷贝
        底层const：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。
            一般非常量可以转化为常量。
    constexpr和常量表达式
        常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
        C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量的表达式。
        constexpr会把定义对象置为[顶层]const
    
2.5 处理类型
    类型别名
        传统别名：使用typedef来定义类型的同义词。 typedef double wages;
        新标准别名：别名声明using： using SI = Sales_item;
    auto类型说明符
        auto类型说明符：让编译器自动推断类型。
        一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型。
        [会]忽略顶层const。
    decltype类型指示符
        decltype：从表达式的类型推断出要定义的变量的类型。
        decltype(f()) sum = x; 推断sum的类型是函数f的返回类型。
        [不会]忽略顶层const。P63
            decltype(*p)结果类型是&int
        如果对变量加括号，编译器会将其认为是一个表达式，如int i-->(i),则decltype((i))得到结果为int&引用。(双层括号)
        赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。

2.6 自定义数据结构
    struct
        类可以以关键字struct开始，紧跟类名和类体。类定义后应加上分号。
        类数据成员：类体定义类的成员。可以为类数据成员提供一个类内初始值。
        头文件(xxx.h)：头文件通常包含只能被定义一次的实体：类、const和constexpr变量。
    预处理器概述：
        预处理器：确保头文件多次包含仍能安全工作。
        当预处理器看到#include标记时，会用指定的头文件内容代替#include。
        头文件保护符：头文件保护符依赖于预处理变量的状态：已定义和未定义。#indef已定义时为真；#inndef未定义时为真。
        头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。