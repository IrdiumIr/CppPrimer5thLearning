# Ch11 关联容器
* 关联容器通过关键字来进行查找和访问
* 两个主要的关联容器是`map`和`set`
* `map`中的元素是键(关键字)值对：关键字用于索引，而值用于保存和索引相关联的数据
* `set`每个元素只包含一个关键字，用来检索关键字是否在`set`中
* `multi`和`unordered`分别表示关键字是否可重复出现和元素排列是否有序；但是每种关联容器必须是一个`map`或一个`set`

## 11.1 使用关联容器
* 1.`map`被称为关联数组，作为键值对的集合，类似于正常的数组，但是其下标并不一定是整数。因为通过的是关键字而非位置来查找值
* 2.`set`只是关键字的简单集合，当我们只需要知道某个值是否存在的时，可以使用`set`来进行核对
* 3.`map`中提取的元素类型为`pair`，需要用`<>`指定键值对分别的类型。`pair`是一个模板类型，保存两个名字是`first`和`second`的公有数据成员；`first`保存关键字而`second`保存对应值
* 4.`set`也是一个模板，同时需要指定`set`中关键字的类型

## 11.2 关联容器概述
* 关联容器同样支持普通容器库定义的普适操作，但是不支持和顺序容器相关的、和位置相关的操作。因为关联容器存储元素是根据关键字而非位置
* 关联容器的迭代器都是双向的

### 11.2.1 定义关联容器
* 1.定义关联容器时需要指定关键字类型：`map`需要同时指明关键字和值的类型，而`set`没有值
* 2.关联容器可以执行列表初始化、拷贝以及从一对值范围来进行初始化
* 3.普通的`map`.`set`都只能使关键字唯一；但是使用了`multi`前缀的两容器没有此限制，允许多个元素具有相同的关键字

### 11.2.2 关键字类型的要求
* 1.关联容器(有序的)关键字类型必须定义元素比较的算法，默认情况下使用`<`运算符来比较两个关键字
* 2.可以向关联容器提供自定义的操作来代替关键字上默认的`<`运算符(像给算法提供自定义比较一样)
* 3.提供的自定义操作必须满足严格弱序：即小于等于
* 4.比较操作类型(应该是一个函数指针)指向我们的自定义操作，`multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);`
* 5.首先需要显式指明返回的是函数指针；其次初始化时可以使用函数名或`&`函数名来调用此函数进行初始化

### 11.2.3 `pair`类型
* 1.`pair`是标准库类型，定义在`utility`中
* 2.一个`pair`保存两个数据成员，不要求是相同类型
* 3.与其他标准库类型不同，`pair`的类型是`public`的可以直接用普通的成员访问符号`.`来进行访问
* 4.`p1 relop p2`的关系运算符通过字典序定义；`make_pair`

## 11.3 关联容器操作
* 对`set`类型，`key_type`和`value_type`是相同的；保存的值本身就是关键字，而在`map`中，元素是键值对。即每个元素是一个`pair`对象
* 由于元素的关键字无法被改变，因此`pair`的关键字部分是`const`的
* 只有`map`及相关类型才定义了`mapped_type`

### 11.3.1 关联容器迭代器
* 1.解引用一个关联容器迭代器时，会得到一个类型为容器的`value_type`的值的引用
* 2.解引用迭代器可以改变`map`的`value_type`的值，但不能改变其中关键字成员的值
* 3.`set`的迭代器是`const`的，只读访问但不允许写入
* 4.通过`begin`和`end`遍历关联容器时，迭代器会按照关键字的升序遍历元素(遵循`<`的顺序)
* 5.关联容器由于其`const`的特性，通常不适合使用泛型算法，因为泛型算法有时需要修改或重排元素；用于只读元素的算法时，效率通常也并不高。因为泛型算法大多搜索序列，而关联容器并不能通过搜索关键字来快速查找
* 6.因此在泛型算法中使用关联容器时，一般作为源序列`(begin, end)`或者目标位置`dest`

### 11.3.2 添加元素
* 1.对于`map`和`set`的有序容器，由于包含的关键字都不相同，因此插入一个已经存在的元素对容器本身没有影响，只有第一个带关键字的元素才会被插入容器中
* 2.对`map`进行插入元素时，元素类型是`pair`。通常没有现成的`pair`类型，需要在参数列表中直接构造
* 3.构造`map`对象的四种方法
* 4.`insert`的返回值类型是一个`pair`，包含了插入指定关键字元素的位置迭代器和一个`bool`值用于指示是否插入成功
* 5.`++ret.first->second` == `++((ret.first)->second)`
* 6.对于`multi`容器的`insert`操作进行调用，总会插入一个新的元素，且返回一个指向新元素的迭代器

### 11.3.3 删除元素
* 1.关联容器的`erase`方法类似顺序容器，可以直接传递给一个迭代器的范围来删除
* 2.关联容器还可以直接给`erase`传递一个`key_type`参数来对关键字匹配的元素进行删除，同时返回删除的数量

### 11.3.4 `map`的下标操作
* 1.`map`和`unordered_map`提供了下标运算符和`at`函数；`multi`的版本不支持是因为可能多个值与一个key关联；`set`不支持是因为没有对应的“值”
* 2.如果关键字不在`map`中，下标运算符会创建一个元素并插入`map`中，且对关联值进行初始化
* 3.下标运算符可能会插入新元素，因此只能对非`const`的`map`使用下标操作
* 4.对`map`进行下标操作，返回类型为`mapped_type`，即关键字对应的值；但解引用一个`map`迭代器，返回类型为`value_type`的`pair`值

### 11.3.5 访问元素
* 1.关联容器提供了若干中查找指定元素的方法，除了下标和`at`外(只适用于非`const`的`map`和`unordered_map`)
* 2.`count`和`find`区别在于前者会返回数值而后者返回位置迭代器；不需要计数的情况下只需要使用`find`即可
* 3.使用下标操作和使用`find`的区别在于你是否想要在`map`中插入一个正在查找的新元素
* 4.在使用`multi`关联容器中查找元素，这些元素通常会相邻存储；因此通常可以通过`count`计数，通过`find`找到首位从而进行遍历
* 5.`lower_bound`和`upper_bound`对于有序关联容器能够返回根据关键值界定的范围
* 6.`equal_range`更直接，能够返回一个`pair`来表示其范围

### 11.3.6 一个单词转换的`map`
* NULL

## 11.4 无序容器
* 1.`C++11`定义了4个无序关联容器，组织元素时并不通过类似`<`的比较运算符，而是通过哈希函数和关键字类型的`==`运算符
* 2.哈希技术通常能够获得更好的平均性能
* 3.通常有序版本和无序版本可以替换，但是输出有所不同
* 4.无序容器在存储上组织为一组桶`(bucket)`，每个桶保存若干个元素(可以为0)，并使用哈希函数将元素映射到桶。